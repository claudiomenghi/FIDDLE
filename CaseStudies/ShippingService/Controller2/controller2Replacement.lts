// This model contains the shipping service with the CONTROLLER.
// The preconditions of the CONTROLLER are described.

//***************************************************************************************************
// ENVIRONMENT
//***************************************************************************************************

set User = {userReq, offerRcvd, usrAck, usrNack, respOk, reqCancelled}
set	ProducerControllable={prodInfoReq, prodReq, prodCancel}
set ProducerMonitorable={infoRcvd}
set Producer = {ProducerControllable, ProducerMonitorable}

set EmptySet={aaa}

set Shipper = {shipInfoReq, costAndTime, shipReq, shipCancel}


set A = {User, Producer, Shipper}


PRODUCER 	= 						(	prodInfoReq	->	REQUESTED		), 
					REQUESTED 	  = (	infoRcvd	->	ORDER_PENDING	),
					ORDER_PENDING = (	prodReq		->	PRODUCER 
										| 
										prodCancel	->	PRODUCER		).

 
SHIPPER 	= 						   (	shipInfoReq	->	REQUESTED		), 
					REQUESTED	 	 = (	costAndTime	->	SHIPPING_PENDING),
					SHIPPING_PENDING = (	shipReq		->	SHIPPER 
											| 
											shipCancel	->	SHIPPER			).


USER = 									(	userReq		->	REQUESTED		), 
					REQUESTED 		  = (	offerRcvd	->	ACK_NACK		),
					ACK_NACK 		  = (	usrAck		->	ACKD 
											| 
											usrNack		->reqCancelled->USER), 
					ACKD 			  = (	respOk		->	USER			).


||Environment = (USER || SHIPPER || PRODUCER).


 
//***************************************************************************************************
// CONTROLLER
//***************************************************************************************************
set PreparingOfferInterface={prodInfoReq,  shipInfoReq,infoRcvd, costAndTime}

set ManageRequestInterface={prodReq, shipReq}
set DeclineRequestInterface={prodCancel, shipCancel}

ControllerSpec =	INIT,
				INIT 				= 	(	userReq 	-> 	PREPARINGOFFER 				),
				box PREPARINGOFFER	= 	(	offerRcvd 	->	WAITINGFORUSERCHOICE 		
										)[PreparingOfferInterface],	
				WAITINGFORUSERCHOICE=	(	usrAck		->	MANAGEREQUEST
											|
											usrNack		-> 	DECLINEREQUEST
										),
				box	MANAGEREQUEST	=	(	respOk 		-> 	INIT	
										)[ManageRequestInterface],
				box DECLINEREQUEST	=	( 	reqCancelled -> INIT	
										)[DeclineRequestInterface].
	

|| Controller =(ControllerSpec).
|| System = (Environment || Controller).

//***************************************************************************************************
// REQUIREMENTS
//***************************************************************************************************

// requirement 1
// 1 the purchase and delivery must only check for some product or shipping info if the user has placed an order.
// the system should not query the services if no user request is received
assert CHECK_PRODUCT = []((F_ShipInfoReq || F_ProdInfoReq) -> F_UserReq)
// expected: NOT OK
// returned: NOT OK

// requirement 2
// 2 an offer is provided to the user only if the furniture and shipping services have confirmed the availability
assert CHECK_OFFER	=	[](F_OfferRcvd -> (F_CostAndTime && F_InfoRcvd))
// expected: NOT OK
// returned:  OK

// requirement 3
// 3 the furniture and the shipping requirements are activated only if the user has decided to purchase
assert FURNITURE_AND_SHIPPING_IF_PURCHASE =	[]((F_ShipReq || F_ProdReq) -> F_UsrAck)
// expected: NOT OK
// returned: OK

// requirement 4
// 4 the purchase and delivery system allows canceling an order only if the user canceled the order
assert ORDER_CANCELING= []((F_ProdCancel || F_ShipCancel) -> F_ReqNacked)
// expected: NOT OK
// returned: OK


// requirement 5
// 5 a request is marked as canceled when both the product ordering and the shipping services have canceled the request
assert CANCELING_AN_ORDER=[](F_ReqCancelled -> (F_ProdCancelled && F_ShipCancelled))
// expected: NOT OK
// returned: NOT OK


// requirement 6
// 6 the purchase and delivery system finishes successfully only when both the product ordering and the shupping service have handled correctly their requests
assert FINISH_SUCCESS=[](F_RespOk -> (F_ProdRequested && F_ShipRequested))
// expected: NOT OK
// returned:  NOT OK


// requirement 7
// 7 the controller should guarantee that infinitely many producs are shipped, the service does not stop its execution
assert  INFINITE_SHIPPING= [](<>F_RespOk)
// expected: NOT OK
// returned: NOT OK




//***************************************************************************************************
// FLUENTS
//***************************************************************************************************
fluent F_RespOk = <respOk, A\{respOk}>	initially False
fluent F_ShipInfoReq = <shipInfoReq, A\{shipInfoReq}> initially False
fluent F_ProdInfoReq = <prodInfoReq, A\{prodInfoReq}> initially False
fluent F_UserReq = <userReq, offerRcvd> initially False
fluent F_OfferRcvd = <offerRcvd, A\{offerRcvd}> initially False
fluent F_ShipReq = <shipReq, A\{shipReq}> initially False
fluent F_ProdReq = <prodReq, A\{prodReq}> initially False
fluent F_UsrAck = <usrAck, respOk> initially False
fluent F_JustUsrAck = <usrAck, A\{usrAck}>  initially False
fluent F_ShipCancel = <shipCancel, A\{shipCancel}> initially False
fluent F_ProdCancel = <prodCancel, A\{prodCancel}>  initially False
fluent F_ShipCancelled = <shipCancel, shipInfoReq> initially False
fluent F_ProdCancelled = <prodCancel, prodInfoReq>  initially False
fluent F_ReqCancelled = <reqCancelled, A\{reqCancelled}> initially False
fluent F_ReqJustCancelled = <reqCancelled, A\{reqCancelled}> initially False
fluent F_ReqNacked = <usrNack, reqCancelled> initially False
fluent F_ShipRequested = <shipReq, shipInfoReq> initially False
fluent F_ProdRequested = <prodReq, prodInfoReq> initially False
fluent F_JustUsrNack = <usrNack, A\{usrNack}> initially False 
fluent F_OfferAck = <offerRcvd, usrAck> initially False




fluent F_CostAndTime = <costAndTime, {shipReq,usrNack}> initially False
fluent F_InfoRcvd = <infoRcvd, {shipReq,usrNack}> initially False




//***************************************************************************************************
// ADDITIONAL CONSTANTS
//***************************************************************************************************
const False = 0
const True = 1

//***************************************************************************************************
// PRECONDITIONS
//***************************************************************************************************
// the PREPARINGOFFER black box state can be entered only if there is a pending request
ltl_precondition CONTROLLER PREPARINGOFFER PRE_PENDING_REQUEST=<>([](F_UserReq && !<>(F_RespOk) && !<>(F_ReqCancelled)))
// expected: OK
// returned: OK

// the MANAGEREQUEST black box state can be entered only if there is a user request followed by an offer
ltl_precondition CONTROLLER MANAGEREQUEST MANAGE_REQUEST_REQUIRES_PENDING_REQUEST=<>([](F_UserReq && <>(F_OfferRcvd)))
// expected: OK
// returned: OK

// the DECLINEREQUEST black box state can be entered only if there is a user request followed by an offer
ltl_precondition CONTROLLER DECLINEREQUEST DECLINE_REQUEST_REQUIRES_PENDING_REQUEST=<>([](F_UserReq && <>(F_OfferRcvd)))
// expected: OK
// returned: OK



fluent F_InfoRcvd_Post = <infoRcvd, A\{infoRcvd}> initially False


fluent F_ProductInfoReqEvent =<prodInfoReq, A\{prodInfoReq}> initially False
fluent F_InfoRcvdEvent = <infoRcvd, A\{infoRcvd}> initially False

fluent F_ShipInfoReqEvent =<shipInfoReq, A\{shipInfoReq}> initially False
fluent F_CostAndTimeEvent = <costAndTime, A\{costAndTime}> initially False


// POST CONDITION STATE 2
ltl_postcondition CONTROLLER PREPARINGOFFER REQUEST_CORRECTLY_PREPARED=
																(
																	(<>[](F_CostAndTime)) 
																	//&& 
																	//(<>([]F_InfoRcvd_Post))	
																)
																//&& <>(F_InfoRcvd_Post)		
																//&& <>(F_ShipInfoReqEvent)															
																//&& [](F_CostAndTimeEvent->X[](!F_CostAndTimeEvent)) 
																//&& [](F_InfoRcvdEvent->X[](!F_InfoRcvdEvent))
																//&& [](F_ShipInfoReqEvent->X[](!F_ShipInfoReqEvent))
																//&& [](F_ProductInfoReqEvent->X[](!F_ProductInfoReqEvent))
																// F_ShipInfoReqEvent becomes true  before F_CostAndTimeEvent
																//&& ((!F_CostAndTimeEvent) U (F_ShipInfoReqEvent))
																// F_ProductInfoReqEvent becomes true  before F_InfoRcvdEvent
																//&& ((!F_InfoRcvdEvent) U (F_ProductInfoReqEvent))
																

fluent F_ProdReq_Post = <prodReq, ManageRequestInterface\{prodReq}> initially False
fluent F_ShipReq_Post = <shipReq, ManageRequestInterface\{shipReq}> initially False

// POST CONDITION STATE 4
ltl_postcondition CONTROLLER MANAGEREQUEST REQUEST_CORRECTLY_MANAGED=(
																<>(F_ProdReq_Post) 
																	&& 
																<>(F_ShipReq_Post)
															)
fluent F_ShipCancel_Post = <shipCancel, DeclineRequestInterface\{shipCancel}> initially False
fluent F_ProdCancel_Post = <prodCancel, DeclineRequestInterface\{prodCancel}>  initially False

// POST CONDITION STATE 5
ltl_postcondition CONTROLLER DECLINEREQUEST CANCEL_REQUEST_CORRECTLY_MANAGED=(
																<>(F_ProdCancel_Post) 
																	&& 
																<>(F_ShipCancel_Post)
															)




replacement ControllerSpec PREPARINGOFFER Subcontroller_PREPARING_OFFER_Spec	=   START,
																					START= 			(	shipInfoReq 	-> 		SHIPINFOREQ),
																					//wrong design
																					//SHIPINFOREQ= 	(	prodInfoReq		->		ENDSTATE),
																					// correct design
																					SHIPINFOREQ= 	(	prodInfoReq		->		COSTANDTIMEREC),
																					COSTANDTIMEREC=	(	costAndTime		->		PRODUCTINFOREQ),
																					PRODUCTINFOREQ=	(	infoRcvd		->		ENDSTATE),
																					final ENDSTATE.@{userReq, offerRcvd, usrAck, usrNack, respOk, reqCancelled,prodInfoReq, prodReq, prodCancel,infoRcvd,shipInfoReq, costAndTime, shipReq, shipCancel}.

|| Subcontroller_PREPARING_OFFER=(Subcontroller_PREPARING_OFFER_Spec).

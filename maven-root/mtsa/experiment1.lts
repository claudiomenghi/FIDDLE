// DISCOVERED STUFFS #****#
// CHANGED/QUESTIONS #~~~~# 

// PARAMETERS
// the number of conditionlist
const MaxCondListIndex = 1
// the number of data condained in the DB
const MAX_DB = 1

// contains the set of the threads
set Threads = {	executive, 
		execCondChecker.{dbMonitor, internal}, 
		actionExecution, 
		database} 


// the signals of the executive
set ExecSignalVal = {clear, ok, planAbort, timeout, conditionFailure}

set CommandStatus = {unchanged, success, failureb, other}  
// Rich: could it also be something different?

// contains the condition variables
set CVs = {	execCV, 		// a new execution plan is available 
		actionCV, 
		condListCV, 
		dbCV, 		 	// the conditional variable wich refers to the database
		actionAckCV}

set Mutexes = {		exec, 
			action, 
			condList, 
			db, 
			CVs} 

// the maximum value of a variable
const MAX_VALUE=0
const MAX_THREADS=1

// THE DATA OF THE DATABASE
range Data = 0..MAX_VALUE

// ------------------------------------------------------------------------------------------

const False = 0
const True = 1
range Boolean = False..True

// Verification Parameters
const Races = False // Warning - need to change the following definitions accordingly


const Null = 0
const Min = 0

// THE STATUS OF THE THREADS
const Idle = 0
const Pending = 1
const Halted = 2
const Running = 3
range STATUS = Idle..Running


// THE CONDITION LIST
range CondListIndices = 0..MaxCondListIndex





set Mutex_CV_Alpha = {Mutexes.{lock, unlock}, CVs.{signal, broadcast, wait, wait_timeout}}
set Vis_Mutex_CV_Alpha = {Mutexes.{lock, unlock}, CVs.{signal, broadcast}}

// Verification Parameters

/* atomic variable access - no races */
set BooleanAlpha = {{read, assign}.[Boolean]}
set StatusAlpha = {status.{read, assign}.[STATUS]}
set SavedWakeUpAlpha = {savedWakeupStruct.{read, assign}.[CondListIndices]}
set CondSetChangedAlpha = {conditionSetChanged.BooleanAlpha}
set DbChangedAlpha = {dbChanged.BooleanAlpha}
set DbInfoAlpha = {info.{read, assign}.[Data]}

/* non-atomic variable access - races */
/*
set BooleanAlpha = {begin_read, begin_assign, {end_read, end_assign}.[Boolean]}
set StatusAlpha = {status.{begin_read, begin_assign, {end_read, end_assign}.[STATUS]}}
set SavedWakeUpAlpha = {savedWakeupStruct.{begin_read, begin_assign, {end_read, end_assign}.[CondListIndices]}}
set CondSetChangedAlpha = {conditionSetChanged.BooleanAlpha}
set DbChangedAlpha = {dbChanged.BooleanAlpha}
set DbInfoAlpha = {info.{begin_read, begin_assign, {end_read, end_assign}.[Data]}}
*/





/*** Here starts a definition for variables that, based on what we want to do, checks for 
 race conditions or not, in which case we donnot always need the begin_read, end_read, etc ***/


// ************************************************************************************************** //
// DEFINITION OF VARIABLES
// ************************************************************************************************** //
/////////////////////////////////
///// MUTEX		           /////
/////////////////////////////////
// specifies the behavior of the mutex, for the specified mutex (passed as parameter)
// all the threads in the set of threads can change the mutex
// Variables, Condition Variables and Mutexes
Mutex (MutexName = Null) = (	
                [thread:Threads].[MutexName].lock 
				-> [thread].[MutexName].unlock 
				-> Mutex).

/////////////////////////////////
///// NORMAL VARIABLES      /////
/////////////////////////////////
// some assumed behavior - has begin end, but does not check for races
// ----- ASSUMED VARIABLE ------
// specifies the behavior of a variable, given its max value and the max number of threads
// it considers the number of readers and threads
Assumed_Var(MaxValue = 0, MaxThreads = 1) = Variable[0][False][0],
											     Variable[val:0..MaxValue][writers:Boolean][readers:0..MaxThreads] = ( 
												        when (!writers && readers<MaxThreads) 
                                                                     begin_read -> 
                                                                    Variable[val][writers][readers+1]
                                                        | 
                                                        when (!writers && readers==0 && MaxThreads>0) 
                                                                    begin_assign -> 
                                                                    end_assign[new:0..MaxValue] -> 
                                                                    Variable[new][False][readers]
                                                        | 
                                                        when (readers>0) 
                                                                    end_read[val] -> 
																   Variable[val][writers][readers-1]
                                                        ).



            


// ------ SIMPLE VARIABLE ------
// it contains a simple variable 
// it does not consider the number of readers and writers
Simpl_Var(MaxValue = 0) =  Variable[0],	
						   Variable[val:0..MaxValue] = (
												assign[new:0..MaxValue] -> 
												Variable[new] 
											|	
                                                read[val] -> 
												Variable[val]).


/////////////////////////////////
///// CONDITION VARIABLES 	/////
/////////////////////////////////
// Synchronization mechanisms need more than just mutual exclusion; also need a way to wait for another thread to do something
// Condition variables: used to wait for a particular condition to become true
minimal CondVar (ConditionVariable = Null) = (	[Threads].[ConditionVariable].signal -> 
                                                [ConditionVariable].broadcast -> 
										        CondVar). 


// Condition variable methods
Wait_CV (Mutex = Null, ConditionVariable = Null) = ([ConditionVariable].lock ->  
													[Mutex].unlock -> 
													[ConditionVariable].wait ->
													// claudio mosso sotto per consistenza con la multiple lock conditional variable	
													//[Mutex].lock -> 
											  		[ConditionVariable].unlock  -> 
													[ConditionVariable].broadcast -> 
													[Mutex].lock -> 
													END). 


ML_Wait_CV (Mutex1 = Null, Mutex2 = Null, ConditionVariable = Null) = (	[ConditionVariable].lock ->  
																	   	[Mutex2].unlock -> 
																		[Mutex1].unlock -> 
																		[ConditionVariable].wait ->
																		[ConditionVariable].unlock  -> 
																		[ConditionVariable].broadcast -> 
																		[Mutex1].lock -> 
																		[Mutex2].lock -> 
																		END). 


Signal_CV (ConditionVariable = Null) = (	[ConditionVariable].lock -> 
											[ConditionVariable].signal ->
											[ConditionVariable].unlock -> 
											END). 

Timed_Wait_CV (Mutex = Null, ConditionVariable = Null, Timeout = Null) = ([ConditionVariable].lock ->  // is it correct? - RICH -
																		  [Mutex].unlock -> 
																		  [ConditionVariable].wait ->
											 							  [ConditionVariable].unlock -> 
																		  WakeUp), 
																		  WakeUp = ( when (!Timeout) [ConditionVariable].broadcast -> 
																									 [Mutex].lock -> 
																									 END
																				   | when (Timeout) [ConditionVariable].wait_timeout -> 
																									[Mutex].lock -> 
																									END). 


//________________________________________________________________________________________________________________________________________________
// INSTANCES
//________________________________________________________________________________________________________________________________________________

// ---- INSTANTIATING THE VARIABLE----
// it contains the switch to choose the variable to be considered --
|| Variable (MaxValue = 1, MaxThreads = 2, Check = False, Detail = True) = 
							if Check then Prop_Var(MaxValue, MaxThreads) 
							else if Detail then Assumed_Var(MaxValue, MaxThreads)
							else Simpl_Var(MaxValue).


// ---- INSTANTIATING THE CONDITIONAL VARIABLE----
// Mutex instances - initially allow all threads to share them - see if that reduces modularity
// CondDB is declared within the ExecCondChecker
|| Exec_Mutex = (Mutex('exec)).
|| Action_Mutex = (Mutex('action)).
|| CondList_Mutex = (Mutex('condList)).
|| DB_Mutex = (Mutex('db)). 

// there is no check over the access (MUTEX), i.e., there is no synchronization between the conditional cariable and the mutex
// CondVar instances
|| ExecCV_CondVar = (CondVar('execCV) || Mutex('execCV)).
|| ActionCV_CondVar = (CondVar('actionCV) || Mutex('actionCV)).
|| ActionAckCV_CondVar = (CondVar('actionAckCV) || Mutex('actionAckCV)).
|| CondListCV_CondVar = (CondVar('condListCV)|| Mutex('condListCV)).
|| DbCV_CondVar = (CondVar('dbCV) || Mutex('dbCV)).


Complete (CV=Null) = (		[CV].add_loop -> 
							Complete 
						| 	[CV].wait -> 
							 Wait),
Wait			   = (		{[CV].broadcast, [CV].wait_timeout} -> 
							Complete).

/********************* properties **************************/

property
  || Prop_Var (MaxValue = 2, MaxThreads = 2) = Assumed_Var(MaxValue, MaxThreads).



//property PROTECT_ACCESS(OfBoolVariable=Null, ByMutex=Null) = (	[ByMutex].lock -> 
//																Access
//															),
//															Access = (	[OfBoolVariable].BooleanAlpha -> 
//																		Access 
//																		| 
//																		[ByMutex].unlock -> 
//																		PROTECT_ACCESS
//																	).

// lock is followed by an unlock
property LOCK_UNLOCK (Mutex = Null) = (		[Mutex].lock -> 
											[Mutex].unlock -> 
											LOCK_UNLOCK
									  ).


// following should be checked on all threads, individually
|| Protect_CC_SavedWakeupStruct(Access = Null) =  	PROTECT_ACCESS('[Access].savedWakeupStruct, 'exec).
|| Protect_CC_ConditionSetChanged(Access = Null) =  PROTECT_ACCESS('[Access].conditionSetChanged, 'condList).
|| Protect_CC_Checker_DbChanged(Access = Null) =  	PROTECT_ACCESS('[Access].dbChanged, 'condDB).
|| Protect_DB_DbChanged(Access = Null) =  			PROTECT_ACCESS('[Access].dbChanged, 'db).
|| Protect_DB_Info(Access = Null) =  				PROTECT_ACCESS('[Access].info, 'db).
|| Protect_AE_Status(Access = Null) =  				PROTECT_ACCESS('[Access].status, 'action).



/********************************************************************** */
/////****************** 		  Database         ******************/////
/********************************************************************** */
/* Methods */


// MUTEX:                       db,
// CONDITIONAL VARIABLES:       dbCV
// 1 - locks the db
// 2 - performs an assignement
// 2 - releases the lock on db
// 3 - signal dbCV
// 4 - locks the db
// 3 - unlocks the db
Database_DBAssert (Access = 'local) = (		db.lock -> 
											[Access].dbVariable.begin_assign -> 
											[Access].dbVariable.end_assign[Data] -> 
											[Access].dbChanged.begin_assign -> 
											[Access].dbChanged.end_assign[True] -> 
											Signal_CV('dbCV);
											Unlock
										),
										Unlock = (	db.unlock -> 
													END
										).

// MUTEX:                       db,
// CONDITIONAL VARIABLES:       
// 1 - locks the db
// 2 - unlocks the db 
Database_DBQuery (WithLock=True, Access = 'local) = 
										if (WithLock) then (
												db.lock -> 
												[Access].info.begin_read -> 
												[Access].info.end_read[Data] -> 
												db.unlock -> 
												END
										)
										else (
												[Access].info.begin_read -> 
												[Access].info.end_read[Data] -> 
                                                END
										).
                                        


// MUTEX:                       db,
// CONDITIONAL VARIABLES:       
// 1 - locks the db
// 2 - unlocks the db
Database_ResourceQuery (Access = 'local) = (
												database.db.lock -> 
												[Access].dbVariable.begin_read -> 
												[Access].dbVariable.end_read[Data] -> 
												database.db.unlock -> 
												END
										).

/* Check whether it is necessary to model this, i.e. the fact that you assume
that external threads will use the locking mechanism and signal
appropriately when the access the database - dbChanged */

Database_Update (Access = 'local) = (			randomPick[changes:Boolean] -> 
								if (changes) then 
									Database_DBAssert(Access);
									Database_Update
								else 
									Database_Update
							) + {local.DbChangedAlpha, local.DbInfoAlpha, Mutex_CV_Alpha}. 


//________________________________________________________________________________________________________________________________________________
// INSTANCES DATABASE
//________________________________________________________________________________________________________________________________________________
/* Variables */

// it is necessary otherwise the Queries are processes that END, thus they generate a deadlock
// Dont read this - it's just a modelling trick - BEGIN
minimal
|| Interm_DbUpd = (Database_Update('local) || forall [cv:CVs] Complete(cv)).
|| PInterm_DbUpdate = (Interm_DbUpd) 
				/ {forall [cv:CVs] {[cv].broadcast/[cv].add_loop}}.

// Dont read this - it's just a modelling trick - END


// the database is made by two threads which requires info and updates the database
// modifies the database
// to add external
|| Database_DbChanged = ( {local}::(dbVariable:Variable(MAX_VALUE, MAX_THREADS, False, True))).
// requires info to the database
// to add external
|| Database_Info = ({local, external}::(info:Variable(MAX_VALUE, MAX_THREADS, False, True))).

/* The actual database */
// check what properties may be violated if updating thread is left unspecified, i.e. if no locks 
// need to be acquired for access of database
|| Database_Thread = (database:(PInterm_DbUpdate || Database_Info || Database_DbChanged))
						/ {forall [cv:CVs] {[cv].broadcast/database.[cv].broadcast},
						   external.database / database.external}
						@ {external, database.Vis_Mutex_CV_Alpha, [CVs]}.
                        


|| FindAssumptions = (Database_Thread || DB_Mutex) 
				/ {external.db /{executive.db, actionExecution.db, execCondChecker.dbMonitor.db, execCondChecker.internal.db}} 
				@ {external}.

/*
minimal 
|| Test = FindAssumptions.
*/

/********************************************************************** */
/////****************** 		  DBMonitor        ******************/////
/********************************************************************** */


// MUTEX:                       db,  condDB
// CONDITIONAL VARIABLES:       dbCV, condListCV
// 1 locks the db
// 2 unlocks the db
// 3 waits over dbCV
// 4 locks the db
// 5 locks the condDB
// 5 signal the condListCV
// 6 unlocks the condDB
// with begin/end read
RC_ExecConditionChecker_DBMonitor = (	db.lock -> 
										WaitForDBChange
										),
										WaitForDBChange = (		database.dbChanged.begin_read -> 
				   												database.dbChanged.end_read[hasDbChanged:False..True] -> 
																if (hasDbChanged == False) 	then 	Wait_CV('db, 'dbCV); 
																									WaitForDBChange
																else 	(	database.dbChanged.begin_assign -> 
																			database.dbChanged.end_assign[False] -> 
																			InformInternal)
															), // reset database dbChanged
										InformInternal = (	condDB.lock -> 
															local.dbChanged.begin_assign -> 
															local.dbChanged.end_assign[True] -> 
															Signal_CV('condListCV) -> 
															Unlock),
										Unlock = (	condDB.unlock -> 
													WaitForDBChange) + 
										{Mutex_CV_Alpha, local.DbChangedAlpha, database.DbChangedAlpha}.

// MUTEX:                       db,  condDB
// CONDITIONAL VARIABLES:       dbCV, condListCV
// 1 locks the db
// 2 unlocks the db
// 3 waits over dbCV
// 4 locks the db
// 5 locks the condDB
// 5 signal the condListCV
// 6 unlocks the condDB
// with read is atomic
NRC_ExecConditionChecker_DBMonitor = (	db.lock -> 
										WaitForDBChange
										),
										WaitForDBChange = (		database.dbChanged.read[hasDbChanged:Boolean] -> 
																if (hasDbChanged == False) then Wait_CV('db, 'dbCV); 
																								WaitForDBChange
																else 	(	database.dbChanged.assign[False] -> 
																			InformInternal)
															), // reset database dbChanged
										InformInternal = (	condDB.lock -> 
															local.dbChanged.assign[True] -> 
															Signal_CV('condListCV) -> 
															Unlock),
										Unlock = (	condDB.unlock ->
													WaitForDBChange) + 
										{Mutex_CV_Alpha, local.DbChangedAlpha, database.DbChangedAlpha}.

//________________________________________________________________________________________________________________________________________________
// INSTANCES DBMONITOR
//________________________________________________________________________________________________________________________________________________
|| ExecConditionChecker_DBMonitor = if (Races == True) 
										then RC_ExecConditionChecker_DBMonitor
										else NRC_ExecConditionChecker_DBMonitor.

// Dont read this - it's just a modelling trick - BEGIN 
minimal
|| Interm_Monitor = (ExecConditionChecker_DBMonitor || forall [cv:CVs] Complete(cv)).
|| PExecConditionChecker_Monitor = (Interm_Monitor) 
						/ {forall [cv:CVs] {[cv].broadcast/[cv].add_loop}}.
// Dont read this - it's just a modelling trick - END

|| ExecConditionChecker_DBMonitor_Thread = (dbMonitor:PExecConditionChecker_Monitor) 
											/{forall [cv:CVs] {[cv].broadcast/dbMonitor.[cv].broadcast}}.

|| Check_DbMonitor_Protects = (ExecConditionChecker_DBMonitor_Thread 
									|| dbMonitor:Protect_CC_Checker_DbChanged('local) 
									|| dbMonitor:Protect_DB_DbChanged('database)).

/********************************************************************** */
/////****************** 		  INTERNAL         ******************/////
/********************************************************************** */
/*** Module internal verification parameters ***/

const CondChecker_Detailed_Access = False
const CheckAccess_SavedWakeupStruct = False
const CheckAccess_ConditionSetChanged = False

/************************************/

// MUTEX:                       condList,  condDB
// CONDITIONAL VARIABLES:       condListCV
// 1 - locks the condList
// 2 - locks the condDB
// 3 - waits (Multiple locks) the condListCV
//      3a  -   unlocks the condDB
//      3b  -   unlocks the condList
//      3c  -   waits the condListCV
// 4 - locks condDB and condList
// 5 - do something
// 6 - unlocks the condDB
// 7 - unlocks the condList
// read splitted into begin read and end read
RC_ExecConditionChecker_Internal = (	condList.lock -> 
										condDB.lock -> 
										WaitForConditions), 
									// change suggested by Rich
									WaitForConditions = (local.conditionSetChanged.begin_read -> 
														 local.conditionSetChanged.end_read[hasSetChanged:Boolean] -> 
														 local.dbChanged.begin_read -> 
														 local.dbChanged.end_read[hasDBChanged:Boolean] ->
					 									 if (!(hasSetChanged || hasDBChanged)) then ML_Wait_CV('condDB, 'condList, 'condListCV);
														 											WaitForConditions
					 									  else ResetFlags),
									ResetFlags = (local.conditionSetChanged.begin_assign -> 
												local.conditionSetChanged.end_assign[False] ->
												local.dbChanged.begin_assign -> 
												local.dbChanged.end_assign[False] -> 
												condDB.unlock -> 
												FindMetConditions),
									FindMetConditions = Database_DBQuery(True, 'database);
														Continue,  // performing the query with true shows the deadlock, and with false the data race
									Continue = (	condList.unlock -> 
													ExecConditionChecker_ProcessCCStructs('local);
													RC_ExecConditionChecker_Internal)+ 
													{Mutex_CV_Alpha, local.DbChangedAlpha, local.SavedWakeUpAlpha, local.CondSetChangedAlpha, database.DbInfoAlpha}\ 
													{randomPick}.

// MUTEX:                       condList,  condDB
// CONDITIONAL VARIABLES:       condListCV
// 1 - locks the condList
// 2 - locks the condDB
// 3 - waits (Multiple locks) the condListCV
//      3a  -   unlocks the condDB
//      3b  -   unlocks the condList
//      3c  -   waits the condListCV
// 4 - locks condDB and condList
// 5 - do something
// 6 - unlocks the condDB
// 7 - unlocks the condList
// read atomic
NRC_ExecConditionChecker_Internal = (	condList.lock -> 
										condDB.lock -> 
										WaitForConditions), // change suggested by Rich
									WaitForConditions = (local.conditionSetChanged.read[hasSetChanged:Boolean] -> 
														local.dbChanged.read[hasDBChanged:Boolean] ->
					 									if (!(hasSetChanged || hasDBChanged)) then ML_Wait_CV('condDB, 'condList, 'condListCV);
																									WaitForConditions
														 else ResetFlags), 
													//claudio
                                    ResetFlags = (	//local.conditionSetChanged.assign[False] ->
													//local.dbChanged.assign[False] -> 
													condDB.unlock -> 
													FindMetConditions),
									FindMetConditions = Database_DBQuery(True, 'database);
														Continue,  // performing the query with true shows the deadlock, and with false the data race
									Continue = (	condList.unlock -> 
													ExecConditionChecker_ProcessCCStructs('local);
													NRC_ExecConditionChecker_Internal)
									+ 
											{Mutex_CV_Alpha, local.DbChangedAlpha, local.SavedWakeUpAlpha, local.CondSetChangedAlpha,database.DbInfoAlpha}
											\ {randomPick}.

//________________________________________________________________________________________________________________________________________________
// INSTANCES INTERNAL
//________________________________________________________________________________________________________________________________________________
|| ExecConditionChecker_Internal = if (Races == True) then 
											RC_ExecConditionChecker_Internal
										else 
											NRC_ExecConditionChecker_Internal.  

|| Checker_SavedWakeupStruct = ({external, internal.local}::(savedWakeupStruct:Variable(MaxCondListIndex, 2, CheckAccess_SavedWakeupStruct, CondChecker_Detailed_Access)) 
									||
									if (CondChecker_Detailed_Access) then 
										(external:Begin_End_Access_Pattern('savedWakeupStruct, MaxCondListIndex))
									).

|| Checker_ConditionSetChanged = ({external, internal.local}::(conditionSetChanged:Variable(True, 2, CheckAccess_ConditionSetChanged, CondChecker_Detailed_Access)) ||
								if (CondChecker_Detailed_Access) then (external:Begin_End_Access_Pattern('conditionSetChanged, True))).


// Dont read this - it's just a modelling trick - BEGIN 
minimal
|| Interm_Int = (ExecConditionChecker_Internal || forall [cv:CVs] Complete(cv)).

|| PExecConditionChecker_Internal = (Interm_Int) 
						/ {forall [cv:CVs] {[cv].broadcast/[cv].add_loop}}.

// Dont read this - it's just a modelling trick - END

compose
|| 	ExecConditionChecker_Internal_Thread = (
									internal:PExecConditionChecker_Internal || 
									Checker_SavedWakeupStruct || 
									Checker_ConditionSetChanged)
									/{forall [cv:CVs] {[cv].broadcast/internal.[cv].broadcast}}.

// I dont remember right now what this is used for - 
// maybe for the race conditions on the database?

|| Abstract_ExecConditionChecker_Internal_Thread =  ExecConditionChecker_Internal_Thread
										@ {Mutex_CV_Alpha, internal.local.DbChangedAlpha, internal.database, external}.


//________________________________________________________________________________________________________________________________________________
// PROPERTIES INTERNAL
//________________________________________________________________________________________________________________________________________________

// - 1 - Locks protect variables as intended
|| Check_Internal_Protects = (ExecConditionChecker_Internal_Thread 
									|| internal:Protect_CC_SavedWakeupStruct('local) 
									|| internal:Protect_CC_ConditionSetChanged('local) 
									|| internal:Protect_CC_Checker_DbChanged('local) 
									|| internal:Protect_DB_Info('database)).

// - 2 - Just checking how internal accesses the savedWakeupStruct 

// - 3 - Consumer producer-related property - need locks for that...

// now checking the consumer producer-related property - need locks for that...
// check it after race conditions, so we can use the simple version of the variable definitions	
// So if Races is true, we dont really care to check and make the 
// composite process Check_Produce_Consume ERROR					

//property 
//Produce_Consume = Unconsumed,
//			Unconsumed = (	external.savedWakeupStruct.read[CondListIndices] -> 
//							Consumed
//						| 	internal.local.savedWakeupStruct.{assign, read}.[CondListIndices] -> 
//							Unconsumed
//						| 	external.savedWakeupStruct.assign.[0] -> 
//							Unconsumed),
//			Consumed = (	external.savedWakeupStruct.assign[0] -> 
//							Unconsumed
//						| 	internal.local.savedWakeupStruct.assign.[CondListIndices] -> 
//							Unconsumed
//						| 	external.savedWakeupStruct.read.[CondListIndices] -> 
//							Consumed) + 
//			{external.savedWakeupStruct.assign.[CondListIndices]}.


// The following are used in order to try our assumption generation algorithms
minimal
|| ExecMutex_Abstraction = (Exec_Mutex) 
							/{internal/execCondChecker.internal,external / {database, executive, actionExecution, dbMonitor}}
							@ {internal, external}.

minimal
|| CondListMutex_Abstraction = (CondList_Mutex) 
								/ {internal/execCondChecker.internal,
								external / {database, executive, actionExecution, dbMonitor}}
								@ {internal, external}.

/* You use the assumption that the environment accesses savedWakeupStruct protected by the exec lock ??? */
External_VarUse_Assumption = (		external.exec.lock -> 
									HasAccess),
									HasAccess = (	external.savedWakeupStruct.read[CondListIndices] -> 
													HasAccess 
												| 	external.savedWakeupStruct.assign[CondListIndices] -> 
													HasAccess 
												| 	external.exec.unlock -> 
													External_VarUse_Assumption
							).


Error = ERROR.

// used for generating assumption 
|| Check_Produce_Consume = if (Races == False) then 
							(ExecConditionChecker_Internal_Thread || Produce_Consume || ExecMutex_Abstraction 
								|| CondListMutex_Abstraction ||  External_VarUse_Assumption)
							else Error
							@ {external.exec, /*external.condList,*/ external.savedWakeupStruct}. // , Mutex_CV_Alpha}.



/********************************************************************** */
/**************************** EXEC COND CHECKER ************************ */
/********************************************************************** */
// GOAL: monitors the state conditions
/* Made up of two threads, Internal and DBMonitor */
/* Here are methods */
// Used to remove all the checking over the conditions



// MUTEX:                       exec,   condList
// CONDITIONAL VARIABLES:       execCV, 
// 1 - locks exec
// 2 - locks condList
// 3 - if bestWakeUp > saved
//      - 3a signal on execCV
// 3 - unlocks condList
// 4 - unlocks condList
// assign made by begin assign and end assign
RC_ExecConditionChecker_ProcessCCStructs (Access = 'local) = 	(	exec.lock -> 
																	condList.lock -> 
																	randomPick[bestWakeUp:CondListIndices] ->
																	[Access].savedWakeupStruct.begin_read -> 
																	[Access].savedWakeupStruct.end_read[saved:CondListIndices] ->
																	if (bestWakeUp > saved) then 
																		UpdateSaved[bestWakeUp] 
																	else 
																		Unlock
																),
																UpdateSaved[i:CondListIndices] = (	
																		[Access].savedWakeupStruct.begin_assign -> 
																		[Access].savedWakeupStruct.end_assign[i] -> 
																		[Access].endAssignment ->
																		randomPick[failOnWakeup:Boolean] ->
																		if (failOnWakeup) then 
																			(	exec.reportExecutionSignal -> 
																				Signal_CV('execCV);
																				Unlock)
								  										else 
																				Signal_CV('execCV);
																				Unlock),
																Unlock = (	condList.unlock -> 
																			exec.unlock -> 
																			END).

// MUTEX:                       exec,   condList
// CONDITIONAL VARIABLES:       execCV, 
// fa una signal su execCV
// assign is atomic
NRC_ExecConditionChecker_ProcessCCStructs (Access = 'local)=(	exec.lock -> 
																condList.lock -> 
																randomPick[bestWakeUp:CondListIndices] ->
																[Access].savedWakeupStruct.read[saved:CondListIndices] ->
																if (bestWakeUp > saved) then 
																		UpdateSaved[bestWakeUp] 
																else Unlock
															),
															UpdateSaved[i:CondListIndices] = (
																		[Access].savedWakeupStruct.assign[i] -> 
																		randomPick[failOnWakeup:Boolean] ->
																		if (failOnWakeup) then 
																				(	exec.reportExecutionSignal -> 
																					Signal_CV('execCV);
																					Unlock)
								  										else Signal_CV('execCV);
																			  Unlock),
															Unlock = (condList.unlock -> 
																	  exec.unlock -> 
																	  END).

// MUTEX:                       condList
// CONDITIONAL VARIABLES:       
// 1 - locks the conditionList
// 2 - unlock the conditionList
ExecConditionChecker_RemoveAllConditionChecks (Access = 'local) = if (Races == True) then (	condList.lock -> 
																							[Access].conditionSetChanged.assign[False] -> 
																							condList.unlock -> 
																							END)
																					 else (
																							condList.lock -> 
																							[Access].conditionSetChanged.begin_assign -> 
																							[Access].conditionSetChanged.end_assign[False] -> 
																							condList.unlock -> 
																							END).
                                                                                            
ExecTimer_RemoveAllTimes = (removeTimes -> END).

// ... and a local mutex
CondDB_Mutex = (	internal.condDB.lock -> 
					internal.condDB.unlock -> 
					CondDB_Mutex
			     | 		
                    dbMonitor.condDB.lock -> 
					dbMonitor.condDB.unlock -> 
					CondDB_Mutex
				).


//________________________________________________________________________________________________________________________________________________
// INSTANCES
//________________________________________________________________________________________________________________________________________________

|| ExecConditionChecker_ProcessCCStructs (Access = 'local) = if (Races == True) 
															then RC_ExecConditionChecker_ProcessCCStructs(Access)
															else NRC_ExecConditionChecker_ProcessCCStructs(Access).
																

|| Checker_DBChanged = ({internal.local, dbMonitor.local}::(dbChanged:Variable(True, 2, False, False))). 


// for this abstraction, all we are trying to achieve is synchronize the two threads
// when database is added, we will also add the entire DBMutex
minimal || DBMutex_Abstraction = (DB_Mutex) 
								/ {internal/execCondChecker.internal, dbMonitor/execCondChecker.dbMonitor}
								@ {internal, dbMonitor}.


/*
minimal || CondListCV_Abstraction = (CondListCV_CondVar)
								/ {internal/execCondChecker.internal, dbMonitor/execCondChecker.dbMonitor}
								@ {{internal, dbMonitor}.condListCV.{lock, unlock}}.
*/




|| External_VarUse_Assumption1 = 	if (Races == True) 	then RC_External_VarUse_Assumption1 
														else NRC_External_VarUse_Assumption1.




|| 	External_VarUse_Assumption2 = if (Races == True) then RC_External_VarUse_Assumption2 
												     else NRC_External_VarUse_Assumption2.


compose
|| ExecCondChecker_NoAbstractions = (		ExecConditionChecker_DBMonitor_Thread || 
											ExecConditionChecker_Internal_Thread || 
											Checker_DBChanged || 
											Checker_SavedWakeupStruct || 
											Checker_ConditionSetChanged || 
											CondDB_Mutex || 
											CondListMutex_Abstraction || 
											DBMutex_Abstraction  || 
											ExecMutex_Abstraction || 
											External_VarUse_Assumption1 || 
											External_VarUse_Assumption2
									).

// First property was violated when internal would do a simple WAIT_CV because it would
// hold the Cond_DB mutex. So had to implement ML_WAIT_CV, where both locks were
// released and then reacquired. 


compose
|| ExecCondChecker = ExecCondChecker_NoAbstractions 
						@ 	{external, {internal, dbMonitor}.Vis_Mutex_CV_Alpha, 
							CVs, {internal, dbMonitor}.database}.

minimal
|| ExecCondChecker_Thread = (execCondChecker:ExecCondChecker)
							/{	execCondChecker / execCondChecker.{dbMonitor, internal}, // environment cannot differentiate between the 2 threads
								external.exec / execCondChecker.external.exec, // mutexes are assumed system-wide
								external.condList / execCondChecker.external.condList,
								external.execCondChecker/execCondChecker.external,
							  	forall [cv:CVs] {[cv].broadcast/execCondChecker.[cv].broadcast}}.



//________________________________________________________________________________________________________________________________________________
// PROPERTIES
//________________________________________________________________________________________________________________________________________________


/* Must make sure this is valid - making two assumptions in one - first about order of begins and ends,
  second about use of lock to access variables */

RC_External_VarUse_Assumption1 = 			(	external.exec.lock -> 
												HasAccess),
											HasAccess = (	external.savedWakeupStruct.begin_read -> 
											  			 	external.savedWakeupStruct.end_read[CondListIndices] -> 
															HasAccess 
															| 
															external.savedWakeupStruct.begin_assign -> 
															external.savedWakeupStruct.end_assign[CondListIndices] -> 
															HasAccess 
															| 
															external.exec.unlock -> 
															RC_External_VarUse_Assumption1
														).

NRC_External_VarUse_Assumption1 = 		(		external.exec.lock -> 
												HasAccess),
											HasAccess = (	external.savedWakeupStruct.read[CondListIndices] -> 
															HasAccess 
														| 	external.savedWakeupStruct.assign[CondListIndices] -> 
															HasAccess 
														| 	external.exec.unlock -> 
															NRC_External_VarUse_Assumption1
														).
                                                        

RC_External_VarUse_Assumption2 = 		(		external.condList.lock -> 
												HasAccess),
											HasAccess = (	external.conditionSetChanged.begin_read -> 
															external.conditionSetChanged.end_read[Boolean] -> 
															HasAccess 
														| 	external.conditionSetChanged.begin_assign -> 
															external.conditionSetChanged.end_assign[Boolean] -> 
															HasAccess
														| 	external.condList.unlock -> 
															RC_External_VarUse_Assumption2
														). 

NRC_External_VarUse_Assumption2 = (		external.condList.lock -> 
										HasAccess),
										HasAccess = (	external.conditionSetChanged.read[Boolean] -> 
														HasAccess 
													|	external.conditionSetChanged.assign[Boolean] -> 
														HasAccess
													| 	external.condList.unlock -> 
														NRC_External_VarUse_Assumption2
													). 

/*************************************************************** */
/**************************** EXECUTIVE ************************ */
/*************************************************************** */
// GOAL: coordinating component
// contains the logic of the executive module, the executive module uses the action module


// MUTEX:                       exec, condList
// CONDITIONAL VARIABLES:       actionCV, execCV
// 1 - locks the exec
// 2 - locks the condList
// 3 - executes the action
// TODO..
// 4 - waits the execCV
//      - unlocks exec
//      - waits on execCV
// 5 - locks exec
// 6 - signal the execCV
Executive = (exec.lock -> // get the lock on the executive and then waits for a plan
			PlanManager),
			box  PlanManager= (removeTimes-> Done),
			Done = Signal_CV('execCV);
					WaitForPlan + {Mutex_CV_Alpha, actionExecution.StatusAlpha, execCondChecker.SavedWakeUpAlpha, execCondChecker.CondSetChangedAlpha}   \ {randomPick}.


//________________________________________________________________________________________________________________________________________________
// INSTANCES EXECUTIVE
//________________________________________________________________________________________________________________________________________________
// Dont read this - it's just a modelling trick - BEGIN
minimal || Interm_Exec = (Executive || forall [cv:CVs] Complete(cv)).

|| PExecutive = (Interm_Exec) 
				/ {forall [cv:CVs] {[cv].broadcast/[cv].add_loop}}.
// Dont read this - it's just a modelling trick - END

minimal
|| Executive_Thread = (executive:PExecutive)
						 / {forall [cv:CVs] {[cv].broadcast/executive.[cv].broadcast}}
						@ {executive.{actionExecution, execCondChecker, Vis_Mutex_CV_Alpha}, CVs}.


//|| Executive_With_Checker = (Executive_Thread || ExecCondChecker_Thread || ExecCV_CondVar || CondListCV_CondVar) 
//							/ { execCondChecker / execCondChecker.{dbMonitor, internal},
//								executive / external}.
							   	 
|| Executive_With_Checker = (Executive_Thread || ExecConditionChecker_Internal_Thread).




property EXEC_LOCK_RELEASED = (exec.lock ->exec.unlock -> EXEC_LOCK_RELEASED).
// expected: satisfied, returned: not satisfied
progress EXEC_LOCK_PROGRESS = {exec.unlock}

|| CHECK_EXEC_LOCK_RELEASED = ( System || EXEC_LOCK_RELEASED).

//________________________________________________________________________________________________________________________________________________
// PROPERTIES EXECUTIVE
//________________________________________________________________________________________________________________________________________________

/* Not updated - BEGIN */
//property Executive_VarUse_Assumption1 = (external.exec.lock -> HasAccess),
//										HasAccess = (		external.savedWakeupStruct.begin_read -> 
//															external.savedWakeupStruct.end_read[CondListIndices] -> 
//															HasAccess 
//														| 
//															external.savedWakeupStruct.begin_assign -> 
//															external.savedWakeupStruct.end_assign[CondListIndices] -> 
//															HasAccess 
//														| 
//															external.exec.unlock -> Executive_VarUse_Assumption1)/
//													 {executive.execCondChecker.savedWakeupStruct/external.savedWakeupStruct, executive.exec/external.exec}.

//property Executive_VarUse_Assumption2 = (external.condList.lock -> HasAccess),
//										HasAccess = (	external.conditionSetChanged.begin_read -> 
//														external.conditionSetChanged.end_read[Boolean] -> 
//														HasAccess 
//													| 
//														external.conditionSetChanged.begin_assign -> 
//														external.conditionSetChanged.end_assign[Boolean] -> 
//														HasAccess
//													| 
//														external.condList.unlock -> 
//														Executive_VarUse_Assumption2)/ 	
//													{executive.execCondChecker.conditionSetChanged/external.conditionSetChanged,executive.condList/external.condList}.

// OK, assumptions discharged
//|| Check_Executive_Assumption = (Executive_Thread).
// changed by claudio
|| Check_Executive_Assumption = (Executive_Thread || Executive_VarUse_Assumption1 || Executive_VarUse_Assumption2).
/* Not updated - END */




/********************************************************************** */
/**************************** ACTION EXECUTION ************************ */
/********************************************************************** */

/* ACTION EXECUTION CLASS METHODS */

ActExec_DoAction (Access = 'local) = (	action.startexecution ->
										action.lock -> 
										[Access].status.begin_read -> 
										[Access].status.end_read[status:STATUS] -> 
										if (status == Running) then 
														ActExec_StopAction(Access);
														ActExec_InstallAction('interrupt);
														ActExec_InstallAction('new);
														Unlock
										else 	ActExec_InstallAction('new);
												Unlock
										),
										Unlock = (	action.unlock -> 
													action.stopexecution ->
													END
										).

ActExec_StopAction (Access = 'local) = (	[Access].status.begin_read -> 
											[Access].status.end_read[status:STATUS] -> 
											if (status == Running) then ([Access].status.begin_assign -> 
																		 [Access].status.end_assign[Halted] -> 
																		 	Signal_CV('actionCV);
																			WaitForAck
																		)
											else END
										),
										WaitForAck = (	[Access].status.begin_read -> 
														[Access].status.end_read[status:STATUS] -> 
														if (status != Idle) then 
																	Wait_CV('action, 'actionAckCV);
																	WaitForAck
											else END
										).

ActExec_AbortAction (Access = 'local) = (	action.lock -> 
											[Access].status.begin_read -> 
											[Access].status.end_read[status:STATUS] -> 
											if (status == Running) then 
													ActExec_StopAction(Access);
													ActExec_InstallAction('interrupt)
											else 	UnlockAction
										),
										UnlockAction = (
												action.unlock -> 
												END
										).

ActExec_InstallAction(Action = Null) = (	[Action].install -> 
											END
										).


//________________________________________________________________________________________________________________________________________________
// INSTANCES ACTION
//________________________________________________________________________________________________________________________________________________
minimal
ActExec_InternalDoAction (Access = 'local) = (randomPick[asynchronousExecution:True..True]  ->
											if (! asynchronousExecution) then 
															Wait_CV('action, 'actionCV);
															ActExec_InternalDoAction 
											// above is inconsistent with code, I believe
											else 
															AsynchronousExec),
											AsynchronousExec = (	rover.start_action -> 
																	action.lock -> 
																	randomPick[timeout:Boolean] -> 
																	WaitForTermination[timeout]),
											WaitForTermination[timeout:Boolean] = (		
																	[Access].status.begin_read -> 
																	[Access].status.end_read[status:STATUS] ->    
											if ((status != Halted) && !timeout) then 
															(	randomPick[random_timeout:Boolean] ->
																Timed_Wait_CV('action, 'actionCV, random_timeout);
																WaitForTermination[random_timeout]
															)
											else CommandResult),
											CommandResult = (	[Access].status.begin_read -> 
																[Access].status.end_read[status:STATUS] -> 				
																if (status == Halted) then (
																			[Access].status.begin_assign -> 
																			[Access].status.end_assign[Idle] -> 
																			Signal_CV('actionAckCV);
																			UnlockAction
																)      
																else CheckCommandStatus
															),
											CheckCommandStatus = (	randomPick[newCmdStatus:CommandStatus] -> // polling for command status from external system
																if (newCmdStatus != 'unchanged) then 
																		Database_DBAssert; 
																		ProcessStatus[newCmdStatus]
  																else (	randomPick[random_timeout:Boolean] -> 
																		WaitForTermination[random_timeout]
																	)
																	),
											ProcessStatus[cmdStatus:CommandStatus] = if (cmdStatus == 'failureb || cmdStatus == 'success)	then (
																			[Access].status.begin_assign -> 
																			[Access].status.end_assign[Idle] -> 
																			UnlockAction
																	)
										 							else (
																		randomPick[random_timeout:Boolean] -> 
																		WaitForTermination[random_timeout]
																	),
											UnlockAction = (action.unlock -> END) . // \ {randomPick}.



|| System = Executive_With_Checker.

//|| System = Executive_Thread.








fluent EXEC_UNLOCKED=<{executive.exec.unlock},{executive.exec.lock}> initially False
fluent EXEC_LOCKED=<{executive.exec.lock},{executive.exec.unlock}> initially False
fluent WAIT_EXEC_CV=<{execCV.wait},{execCV.unlock}> initially False
fluent SIGNAL_EXEC_CV=<{execCV.signal},{execCV.unlock}> initially False
fluent LOCK_EXEC_CV=<{execCV.lock},{execCV.unlock}> initially False
fluent COND_LIST_LOCKED=<{executive.condList.lock},{executive.condList.unlock}> initially False
fluent ACTIONEXECUTION=<{executive.action.lock},{executive.action.unlock}> initially False
fluent EXECUTIVE_READS_PENDING_PLAN=<{local.pendingPlan.end_read[True]},{resetExecutionSignal}> initially False
fluent INTERNAL_WRITING_PLAN=<{local.savedWakeupStruct.begin_assign},{local.endAssignment}> initially False

// ---------------------------EXPERIMENT 1 PROPERTIES-----------------------------
// property P1:
// whenver the exec waits for the execCV it releases the exec lock 
assert EXEC_LOCKED_RELEASED = [](<>(WAIT_EXEC_CV)-><>(EXEC_UNLOCKED U WAIT_EXEC_CV))

								//& (!WAIT_EXEC_CV)))

// property P2:
// the action can be executed only if the executive possesses the lock
assert ACTION_EXECUTION_REQUIRES_EXECLOCK=[](ACTIONEXECUTION-> EXEC_LOCKED)


// property P3:
// the executive forces the internal to not write data of a new plan until the Executive has used the data of the previous plan
assert ALL_PLANS_ARE_PROCESSED=[]((INTERNAL_WRITING_PLAN &&<>EXECUTIVE_READS_PENDING_PLAN) -> (INTERNAL_WRITING_PLAN U<>(!INTERNAL_WRITING_PLAN U EXECUTIVE_READS_PENDING_PLAN)))

// property P4:
// the executive obtains the lock on the condition list only if it already has the lock on the exec
assert LOCK_CONDLIST_ONLYIF_EXECLOCKED=[](COND_LIST_LOCKED -> EXEC_LOCKED)




// -----------------------------COMMENTS-------------------------------

// - To execute the solution for update controllers select in the dropdown menu 
// the "UPDATE_CONTROLLER" label, and then press the compose button.
// - In the section of UPDATING CONTROLLER SPEC, in this file, you can spec
// different transition requeriments presented in the paper.
// - You can animate the controller obtained pressing the blue A in the top bar
// - If you want to add green raw element to be process, change Colours set definition
// and uncomment the 

// ---------------------------ENVIRONMENTS-----------------------------

//ACTION SETS
//set Colours = {yellow, red, green}
const CantId = 2
range Ids = 1..CantId
set ControllableActions = {in[Ids], drill[Ids], polish[Ids], clean[Ids], trash[Ids], out[Ids], reset[Ids]}
set NewControllableActions = {in[Ids], drill[Ids], paint[Ids], clean[Ids], trash[Ids], out[Ids], reset[Ids]}
set Alphabet = {ControllableActions, drillOk[Ids], polishOk[Ids], cleanOk[Ids], trashOk[Ids]}

//Domain Old Model
	PRODUCTION_CELL_OLD = (in[i:Ids] -> WAITING_ARM),
	WAITING_ARM = (Alphabet\{out[i:Ids],reset[i:Ids],in[i:Ids]} -> WAITING_ARM
		| out[i:Ids] -> reset[i] -> PRODUCTION_CELL_OLD).


	ARM = ( polish[i:Ids] -> POLISHED[i] 
		| drill[i:Ids] -> DRILLED[i]
		| clean[i:Ids] -> CLEANED[i]
		| trash[i:Ids] -> TRASHED[i]
		| out[i:Ids] -> reset[i] -> ARM),
	DRILLED[i:Ids] = (drillOk[i] -> ARM),
	POLISHED[i:Ids] = (polishOk[i] -> ARM),
	TRASHED[i:Ids] = (trashOk[i] -> ARM),
	CLEANED[i:Ids] = (cleanOk[i] -> ARM).

//Domain New Model
	PRODUCTION_CELL_NEW = (in -> ARM),
	ARM = ( drill -> DRILLED
		| clean -> CLEANED
		| paint -> PAINTED
		| trash -> TRASHED
		| out -> reset -> PRODUCTION_CELL_NEW),
	DRILLED = (drillOk -> ARM),
	PAINTED = (paintOk -> ARM),
	TRASHED = (trashOk -> ARM),
	CLEANED = (cleanOk -> ARM).


||OLD_ENV = (PRODUCTION_CELL_OLD || ARM).
||NEW_ENV = (PRODUCTION_CELL_NEW).
/*

//DEFINED FLUENTS 
fluent HaveDrilledC[c:Colours] = <drillOk[c],{in[c],trash[c]}>
fluent DrillPendingC[c:Colours] = <drill[c],{drillOk[c],trash[c]}>
fluent PolishC[c:Colours] = <polishOk[c], {in[c],trash[c]}>
fluent PolishPendingC[c:Colours] = <polish[c], {polishOk[c],trash[c]}>
fluent CleanC[c:Colours] = <cleanOk[c], {in[c],trash[c]}>
fluent CleanPendingC[c:Colours] = <clean[c], {cleanOk[c],trash[c]}>
fluent PaintC[c:Colours] = <paintOk[c], {in[c],trash[c]}>
fluent PaintPendingC[c:Colours] = <paint[c], {paintOk[c],trash[c]}>

fluent RedIn = <in['red],{out['red],trash['red]}>
fluent YellowIn = <in['yellow],{out['yellow],trash['yellow]}>
fluent GreenIn = <in['green],{out['green],trash['green]}>

fluent HaveDrilledRed = <drillOk['red], {in['red],trash['red]}>
fluent HaveDrilledYellow = <drillOk['yellow], {in['yellow],trash['yellow]}>
fluent HaveDrilledGreen = <drillOk['green], {in['green],trash['green]}>
fluent DrillPendingRed = <drill['red],{drillOk['red],trash['red]}>
fluent DrillPendingYellow = <drill['yellow],{drillOk['yellow],trash['yellow]}>
fluent DrillPendingGreen = <drill['green],{drillOk['green],trash['green]}>

fluent PolishRed = <polishOk['red], {in['red],trash['red]}>
fluent PolishYellow = <polishOk['yellow], {in['yellow],trash['yellow]}>
fluent PolishGreen = <polishOk['green], {in['green],trash['green]}>
fluent PolishPendingRed = <polish['red],polishOk['red]>
fluent PolishPendingYellow = <polish['yellow],polishOk['yellow]>
fluent PolishPendingGreen = <polish['green],polishOk['green]>

fluent CleanRed = <cleanOk['red], {in['red],trash['red]}>
fluent CleanYellow = <cleanOk['yellow], {in['yellow],trash['yellow]}>
fluent CleanGreen = <cleanOk['green], {in['green],trash['green]}>
fluent CleanPendingRed = <clean['red],{cleanOk['red],trash['red]}>
fluent CleanPendingYellow = <clean['yellow],{cleanOk['yellow],trash['yellow]}>
fluent CleanPendingGreen = <clean['green],{cleanOk['green],trash['green]}>

fluent PaintRed = <paintOk['red], {in['red],trash['red]}>
fluent PaintYellow = <paintOk['yellow], {in['yellow],trash['yellow]}>
fluent PaintGreen = <paintOk['green], {in['green],trash['green]}>
fluent PaintPendingRed = <paint['red],{paintOk['red],trash['red]}>
fluent PaintPendingYellow = <paint['yellow],{paintOk['yellow],trash['yellow]}>
fluent PaintPendingGreen = <paint['green],{paintOk['green],trash['green]}>

fluent OldToolApplied[c:Colours] = <{drillOk[c],cleanOk[c],polishOk[c]},{out[c],trash[c]}>
fluent NewToolApplied[c:Colours] = <{paintOk[c],drillOk[c],cleanOk[c]},{out[c],trash[c]}>
fluent AnyToolApplied[c:Colours] = <{polishOk[c],paintOk[c],drillOk[c],cleanOk[c]},{out[c],trash[c]}>
fluent Processing[c:Colours] = <in[c],{out[c],trash[c]}>
fluent TrashMadeRed = <trash['red],in['red]>
fluent TrashMadeYellow = <trash['yellow],in['yellow]>
fluent TrashC[c:Colours] = <trash[c],in[c]>

// ---------------------------OLD CONTROLLER SPEC-----------------------------

assert OLD_TOOL_ORDER = forall [c:Colours] ((CleanPendingC[c] -> PolishC[c]) && (PolishPendingC[c] -> HaveDrilledC[c]))
assert OLD_TOOLS_POLICY = forall [c:Colours] ( (drill[c] || polish[c] || clean[c] ) -> Processing[c])
assert OLD_OUT_IF_FINISHED = forall [c:Colours] (out[c] -> (HaveDrilledC[c] && PolishC[c] && CleanC[c]))
assert OLD_ONLY_ONE_COLOUR = forall [c:Colours] ( in[c] -> (!OldToolApplied[c] && !DrillPendingC[c] && !PolishPendingC[c] && !CleanPendingC[c]) )
assert DRILL_ONCE = forall [c:Colours] ( drill[c] -> !HaveDrilledC[c] )
assert POLISH_ONCE = forall [c:Colours] ( polish[c] -> !PolishC[c] )
assert CLEAN_ONCE = forall [c:Colours] ( clean[c] -> !CleanC[c] )
assert AVOID_TRASHING = forall [c:Colours] ( !trash[c])

ltl_property P_OLD_TOOL_ORDER = []OLD_TOOL_ORDER
ltl_property P_OLD_TOOLS_POLICY = []OLD_TOOLS_POLICY
ltl_property P_OLD_OUT_IF_FINISHED = []OLD_OUT_IF_FINISHED
ltl_property P_OLD_ONLY_ONE_COLOUR = []OLD_ONLY_ONE_COLOUR
ltl_property P_DRILL_ONCE = []DRILL_ONCE
ltl_property P_POLISH_ONCE = []POLISH_ONCE
ltl_property P_CLEAN_ONCE = []CLEAN_ONCE
ltl_property P_AVOID_TRASHING = []AVOID_TRASHING

controllerSpec DRILL_POLISH_CLEAN = {
	safety = {P_OLD_TOOL_ORDER, 
			P_DRILL_ONCE, P_CLEAN_ONCE,
			P_OLD_TOOLS_POLICY, P_POLISH_ONCE, P_AVOID_TRASHING,
			P_OLD_OUT_IF_FINISHED, P_OLD_ONLY_ONE_COLOUR
			}
	controllable = {ControllableActions}
}
controller ||C_DRILL_POLISH_CLEAN = (OLD_ENV)~{DRILL_POLISH_CLEAN}.
||DrillPolishClean = (C_DRILL_POLISH_CLEAN || OLD_ENV).


// ---------------------------NEW CONTROLLER SPEC-----------------------------

assert NEW_TOOL_ORDER = forall [c:Colours] ((DrillPendingC[c] -> PaintC[c]) && (PaintPendingC[c] -> CleanC[c]) )
assert NEW_TOOLS_POLICY = forall [c:Colours] ( (drill[c] || paint[c] || clean[c] ) -> Processing[c])
assert NEW_OUT_IF_FINISHED = forall [c:Colours] (out[c] -> (HaveDrilledC[c] && PaintC[c] && CleanC[c]))
assert NEW_ONLY_ONE_COLOUR = forall [c:Colours] ( in[c] -> (!NewToolApplied[c] && !DrillPendingC[c] && !PaintPendingC[c] && !CleanPendingC[c]) )
assert PAINT_ONCE = forall [c:Colours] ( paint[c] -> !PaintC[c] )

ltl_property P_NEW_TOOL_ORDER = []NEW_TOOL_ORDER
ltl_property P_NEW_TOOLS_POLICY = []NEW_TOOLS_POLICY
ltl_property P_NEW_OUT_IF_FINISHED = []NEW_OUT_IF_FINISHED
ltl_property P_NEW_ONLY_ONE_COLOUR = []NEW_ONLY_ONE_COLOUR
ltl_property P_PAINT_ONCE = []PAINT_ONCE

controllerSpec CLEAN_PAINT_DRILL = {
	safety = {P_NEW_TOOL_ORDER, 
			P_DRILL_ONCE, P_CLEAN_ONCE,
			P_NEW_TOOLS_POLICY, P_PAINT_ONCE, P_AVOID_TRASHING,
			P_NEW_OUT_IF_FINISHED, P_NEW_ONLY_ONE_COLOUR
			}
	controllable = {NewControllableActions}
}
controller ||C_CLEAN_PAINT_DRILL = (NEW_ENV)~{CLEAN_PAINT_DRILL}.
||CleanPaintDrill = (C_CLEAN_PAINT_DRILL||NEW_ENV).

// ---------------------------UPDATING CONTROLLER SPEC-----------------------------

fluent InTransition = <beginUpdate,startNewSpec>

assert S_OLD = (OLD_TOOL_ORDER && OLD_TOOLS_POLICY && OLD_OUT_IF_FINISHED && OLD_ONLY_ONE_COLOUR && POLISH_ONCE && DRILL_ONCE && CLEAN_ONCE)
assert S_NEW = (NEW_TOOL_ORDER && NEW_TOOLS_POLICY && NEW_OUT_IF_FINISHED && NEW_ONLY_ONE_COLOUR && PAINT_ONCE && DRILL_ONCE && CLEAN_ONCE)

ltl_property T_REMOVE_POLISHED = [] forall [c:Colours] ((reconfigure -> (!PolishC[c] && !PolishPendingC[c])) && 
								(startNewSpec -> Reconfigure) && 
								(InTransition -> ( ((out[c] -> (!PolishC[c])) && (in[c] ->!AnyToolApplied[c])) || trash[c]) ) )

updatingController UpdCont = {
    oldController = DrillPolishClean,
    oldEnvironment = OLD_ENV,
    newEnvironment = NEW_ENV,
    oldGoal = DRILL_POLISH_CLEAN,
    newGoal = CLEAN_PAINT_DRILL,
    transition = T_REMOVE_POLISHED,
    nonblocking,
    updateFluents = {
		{HaveDrilledRed,HaveDrilledRed},
		{HaveDrilledYellow,HaveDrilledYellow},
		{CleanRed,CleanRed},
		{CleanYellow,CleanYellow},
		{RedIn,RedIn},
		{YellowIn,YellowIn},
		{DrillPendingRed,DrillPendingRed},
		{DrillPendingYellow,DrillPendingYellow},
		{CleanPendingRed,CleanPendingRed},
		{CleanPendingYellow,CleanPendingYellow},
		{PolishPendingRed,FALSE},
		{PolishPendingYellow,FALSE},
		{PolishRed,FALSE},
		{PolishYellow,FALSE},
		{FALSE,PaintPendingRed},
		{FALSE,PaintPendingYellow},
		{FALSE,PaintRed},
		{FALSE,PaintYellow},
	}
}

||UPDATE_CONTROLLER = UpdCont.
// ---------------------------TEST AND RESULTS-----------------------------
fluent StopOldSpec = <stopOldSpec, beginUpdate>
fluent StartNewSpec = <startNewSpec,beginUpdate>
fluent Reconfigure = <reconfigure, beginUpdate>

assert TEST_FORMULA1 = (S_OLD W stopOldSpec)
assert TEST_FORMULA2 = [](startNewSpec -> []S_NEW)
assert TEST_FORMULA3 = [](stopOldSpec -> X (!stopOldSpec))
assert TEST_FORMULA4 = [](beginUpdate -> (<>stopOldSpec && <>startNewSpec && <>reconfigure))
assert TEST_FINAL_FORMULA = ((S_OLD W stopOldSpec) && [](startNewSpec -> []S_NEW) && [](stopOldSpec -> X(!stopOldSpec)))
*/
